.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Smart::Comments 3"
.TH Smart::Comments 3 "2009-12-20" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Smart::Comments \- Comments that do more than just sit there
.SH "VERSION"
.IX Header "VERSION"
This document describes Smart::Comments version 1.0.4
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Smart::Comments;
\&
\&    my $var = suspect_value();
\&
\&    ### $var
\&
\&    ### got: $var
\&
\&    ### Now computing value...
\&
\&    # and when looping:
\&
\&    for my $big_num (@big_nums) {  ### Factoring...      done
\&        factor($big_num);
\&    }
\&
\&    while ($error > $tolerance) {  ### Refining\-\-\->      done
\&        refine_approximation()
\&    }
\&
\&    for (my $i=0; $i<$MAX_INT; $i++) {   ### Working===[%]     done
\&        do_something_expensive_with($i);
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Smart comments provide an easy way to insert debugging and tracking code
into a program. They can report the value of a variable, track the
progress of a loop, and verify that particular assertions are true.
.PP
Best of all, when you're finished debugging, you don't have to remove them.
Simply commenting out the \f(CW\*(C`use Smart::Comments\*(C'\fR line turns them back into
regular comments. Leaving smart comments in your code is smart because if you
needed them once, you'll almost certainly need them again later.
.SH "INTERFACE"
.IX Header "INTERFACE"
All smart comments start with three (or more) \f(CW\*(C`#\*(C'\fR characters. That is,
they are regular \f(CW\*(C`#\*(C'\fR\-introduced comments whose first two (or more)
characters are also \f(CW\*(C`#\*(C'\fR's.
.Sh "Using the Module"
.IX Subsection "Using the Module"
The module is loaded like any other:
.PP
.Vb 1
\&    use Smart::Comments;
.Ve
.PP
When loaded it filters the remaining code up to the next:
.PP
.Vb 1
\&    no Smart::Comments;
.Ve
.PP
directive, replacing any smart comments with smart code that implements the
comments behaviour.
.PP
If you're debugging an application you can also invoke it with the module from
the command-line:
.PP
.Vb 1
\&    perl \-MSmart::Comments $application.pl
.Ve
.PP
Of course, this only enables smart comments in the application file itself,
not in any modules that the application loads.
.PP
You can also specify particular levels of smartness, by including one or more
markers as arguments to the \f(CW\*(C`use\*(C'\fR:
.PP
.Vb 1
\&    use Smart::Comments \*(Aq###\*(Aq, \*(Aq####\*(Aq;
.Ve
.PP
These arguments tell the module to filter only those comments that start with
the same number of \f(CW\*(C`#\*(C'\fR's. So the above \f(CW\*(C`use\*(C'\fR statement would \*(L"activate\*(R" any
smart comments of the form:
.PP
.Vb 1
\&    ###   Smart...
\&
\&    ####  Smarter...
.Ve
.PP
but not those of the form:
.PP
.Vb 1
\&    ##### Smartest...
.Ve
.PP
This facility is useful for differentiating progress bars (see
\&\*(L"Progress Bars\*(R"), which should always be active, from debugging
comments (see \*(L"Debugging via Comments\*(R"), which should not:
.PP
.Vb 1
\&    #### Debugging here...
\&
\&    for (@values) {         ### Progress: 0...  100
\&        do_stuff();
\&    }
.Ve
.PP
Note that, for simplicity, all smart comments described below will be
written with three \f(CW\*(C`#\*(C'\fR's; in all such cases, any number of \f(CW\*(C`#\*(C'\fR's
greater than three could be used instead.
.Sh "Debugging via Comments"
.IX Subsection "Debugging via Comments"
The simplest way to use smart comments is for debugging. The module
supports the following forms, all of which print to \f(CW\*(C`STDERR\*(C'\fR:
.ie n .IP """### LABEL : EXPRESSION""" 4
.el .IP "\f(CW### LABEL : EXPRESSION\fR" 4
.IX Item "### LABEL : EXPRESSION"
The \s-1LABEL\s0 is any sequence of characters up to the first colon. 
The \s-1EXPRESSION\s0 is any valid Perl expression, including a simple variable.
When active, the comment prints the label, followed by the value of the
expression. For example:
.Sp
.Vb 2
\&    ### Expected: 2 * $prediction
\&    ###      Got: $result
.Ve
.Sp
prints:
.Sp
.Vb 2
\&    ### Expected: 42
\&    ###      Got: 13
.Ve
.ie n .IP """### EXPRESSION""" 4
.el .IP "\f(CW### EXPRESSION\fR" 4
.IX Item "### EXPRESSION"
The \s-1EXPRESSION\s0 is any valid Perl expression, including a simple
variable. When active, the comment prints the expression, followed by
the value of the expression. For example:
.Sp
.Vb 2
\&    ### 2 * $prediction
\&    ### $result
.Ve
.Sp
prints:
.Sp
.Vb 2
\&    ### 2 * $prediction: 42
\&    ### $result: 13
.Ve
.ie n .IP """### TEXT...""" 4
.el .IP "\f(CW### TEXT...\fR" 4
.IX Item "### TEXT..."
The \s-1TEXT\s0 is any sequence of characters that end in three dots.
When active, the comment just prints the text, including the dots. For
example:
.Sp
.Vb 1
\&    ### Acquiring data...
\&
\&    $data = get_data();
\&
\&    ### Verifying data...
\&
\&    verify_data($data);
\&
\&    ### Assimilating data...
\&
\&    assimilate_data($data);
\&
\&    ### Tired now, having a little lie down...
\&
\&    sleep 900;
.Ve
.Sp
would print:
.Sp
.Vb 1
\&    ### Acquiring data...
\&
\&    ### Verifying data...
\&
\&    ### Assimilating data...
\&
\&    ### Tired now, having a little lie down...
.Ve
.Sp
as each phase commenced. This is particularly useful for tracking down
precisely where a bug is occurring. It is also useful in non-debugging
situations, especially when batch processing, as a simple progress
feedback mechanism.
.Sp
Within a textual smart comment you can use the special sequence \f(CW\*(C`<now>\*(C'\fR (or \f(CW\*(C`<time>\*(C'\fR or \f(CW\*(C`<when>\*(C'\fR) which is replaced with a
timestamp. For example:
.Sp
.Vb 1
\&    ### [<now>] Acquiring data...
.Ve
.Sp
would produce something like:
.Sp
.Vb 1
\&    ### [Fri Nov 18 15:11:15 EST 2005] Acquiring data...
.Ve
.Sp
There are also \*(L"spacestamps\*(R": \f(CW\*(C`<here>\*(C'\fR (or \f(CW\*(C`<line>\*(C'\fR or \f(CW\*(C`<loc>\*(C'\fR or \f(CW\*(C`<place>\*(C'\fR or \f(CW\*(C`<where>\*(C'\fR):
.Sp
.Vb 1
\&    ### Acquiring data at <loc>...
.Ve
.Sp
to produce something like:
.Sp
.Vb 1
\&    ### Acquiring data at "demo.pl", line 7...
.Ve
.Sp
You can, of course, use both in the same comment as well.
.Sh "Checks and Assertions via Comments"
.IX Subsection "Checks and Assertions via Comments"
.ie n .IP """### require: BOOLEAN_EXPR""" 4
.el .IP "\f(CW### require: BOOLEAN_EXPR\fR" 4
.IX Item "### require: BOOLEAN_EXPR"
.PD 0
.ie n .IP """### assert:  BOOLEAN_EXPR""" 4
.el .IP "\f(CW### assert:  BOOLEAN_EXPR\fR" 4
.IX Item "### assert:  BOOLEAN_EXPR"
.ie n .IP """### ensure:  BOOLEAN_EXPR""" 4
.el .IP "\f(CW### ensure:  BOOLEAN_EXPR\fR" 4
.IX Item "### ensure:  BOOLEAN_EXPR"
.ie n .IP """### insist:  BOOLEAN_EXPR""" 4
.el .IP "\f(CW### insist:  BOOLEAN_EXPR\fR" 4
.IX Item "### insist:  BOOLEAN_EXPR"
.PD
These four are synonyms for the same behaviour. The comment evaluates
the expression in a boolean context. If the result is true, nothing more
is done. If the result is false, the comment throws an exception listing
the expression, the fact that it failed, and the values of any variables
used in the expression.
.Sp
For example, given the following assertion:
.Sp
.Vb 1
\&    ### require: $min < $result && $result < $max
.Ve
.Sp
if the expression evaluated false, the comment would die with the following
message:
.Sp
.Vb 4
\&    ### $min < $result && $result < $max was not true at demo.pl line 86.
\&    ###     $min was: 7
\&    ###     $result was: 1000004
\&    ###     $max was: 99
.Ve
.ie n .IP """### check:   BOOLEAN_EXPR""" 4
.el .IP "\f(CW### check:   BOOLEAN_EXPR\fR" 4
.IX Item "### check:   BOOLEAN_EXPR"
.PD 0
.ie n .IP """### confirm: BOOLEAN_EXPR""" 4
.el .IP "\f(CW### confirm: BOOLEAN_EXPR\fR" 4
.IX Item "### confirm: BOOLEAN_EXPR"
.ie n .IP """### verify:  BOOLEAN_EXPR""" 4
.el .IP "\f(CW### verify:  BOOLEAN_EXPR\fR" 4
.IX Item "### verify:  BOOLEAN_EXPR"
.PD
These three are synonyms for the same behaviour. The comment evaluates
the expression in a boolean context. If the result is true, nothing more
is done. If the result is false, the comment prints a warning message
listing the expression, the fact that it failed, and the values of any
variables used in the expression.
.Sp
The effect is identical to that of the four assertions listed earlier, except
that \f(CW\*(C`warn\*(C'\fR is used instead of \f(CW\*(C`die\*(C'\fR.
.Sh "Progress Bars"
.IX Subsection "Progress Bars"
You can put a smart comment on the same line as any of the following
types of Perl loop:
.PP
.Vb 1
\&    foreach my VAR ( LIST ) {       ### Progressing...   done
\&
\&    for my VAR ( LIST ) {           ### Progressing...   done
\&
\&    foreach ( LIST ) {              ### Progressing...   done
\&
\&    for ( LIST ) {                  ### Progressing...   done
\&
\&    while (CONDITION) {             ### Progressing...   done
\&
\&    until (CONDITION) {             ### Progressing...   done
\&
\&    for (INIT; CONDITION; INCR) {   ### Progressing...   done
.Ve
.PP
In each case, the module animates the comment, causing the dots to
extend from the left text, reaching the right text on the last
iteration. For \*(L"open ended\*(R" loops (like \f(CW\*(C`while\*(C'\fR and C\-style \f(CW\*(C`for\*(C'\fR
loops), the dots will never reach the right text and their progress
slows down as the number of iterations increases.
.PP
For example, a smart comment like:
.PP
.Vb 1
\&    for (@candidates) {       ### Evaluating...     done
.Ve
.PP
would be animated is the following sequence (which would appear
sequentially on a single line, rather than on consecutive lines):
.PP
.Vb 1
\&    Evaluating                          done
\&
\&    Evaluating......                    done
\&
\&    Evaluating.............             done
\&
\&    Evaluating...................       done
\&
\&    Evaluating..........................done
.Ve
.PP
The module animates the first sequence of three identical characters in
the comment, provided those characters are followed by a gap of at least
two whitespace characters. So you can specify different types of
progress bars. For example:
.PP
.Vb 1
\&    for (@candidates) {       ### Evaluating:::     done
.Ve
.PP
or:
.PP
.Vb 1
\&    for (@candidates) {       ### Evaluating===     done
.Ve
.PP
or:
.PP
.Vb 1
\&    for (@candidates) {       ### Evaluating|||     done
.Ve
.PP
If the characters to be animated are immediately followed by other
non-whitespace characters before the gap, then those other non-whitespace
characters are used as an \*(L"arrow head\*(R" or \*(L"leader\*(R" and are pushed right
by the growing progress bar. For example:
.PP
.Vb 1
\&    for (@candidates) {       ### Evaluating===|    done
.Ve
.PP
would animate like so:
.PP
.Vb 1
\&    Evaluating|                         done
\&
\&    Evaluating=====|                    done
\&
\&    Evaluating============|             done
\&
\&    Evaluating==================|       done
\&
\&    Evaluating==========================done
.Ve
.PP
If a percentage character (\f(CW\*(C`%\*(C'\fR) appears anywhere in the comment, it is
replaced by the percentage completion. For example:
.PP
.Vb 1
\&    for (@candidates) {       ### Evaluating [===|    ] % done
.Ve
.PP
animates like so:
.PP
.Vb 1
\&    Evaluating [|                ]   0% done
\&
\&    Evaluating [===|             ]  25% done
\&
\&    Evaluating [========|        ]  50% done
\&
\&    Evaluating [============|    ]  75% done
\&
\&    Evaluating [=================] 100% done
.Ve
.PP
If the \f(CW\*(C`%\*(C'\fR is in the \*(L"arrow head\*(R" it moves with the progress bar. For
example:
.PP
.Vb 1
\&    for (@candidates) {       ### Evaluating |===[%]    |
.Ve
.PP
would be aninated like so:
.PP
.Vb 1
\&    Evaluating |[0%]                       |
\&
\&    Evaluating |=[25%]                     |
\&
\&    Evaluating |========[50%]              |
\&
\&    Evaluating |===============[75%]       |
\&
\&    Evaluating |===========================|
.Ve
.PP
For \*(L"open-ended\*(R" loops, the percentage completion is unknown, so the module
replaces each \f(CW\*(C`%\*(C'\fR with the current iteration count. For example:
.PP
.Vb 1
\&    while ($next ne $target) {       ### Evaluating |===[%]    |
.Ve
.PP
would animate like so:
.PP
.Vb 1
\&    Evaluating |[0]                        |
\&
\&    Evaluating |=[2]                       |
\&
\&    Evaluating |==[3]                      |
\&
\&    Evaluating |===[5]                     |
\&
\&    Evaluating |====[7]                    |
\&
\&    Evaluating |=====[8]                   |
\&
\&    Evaluating |======[11]                 |
.Ve
.PP
Note that the non-sequential numbering in the above example is a result
of the \*(L"hurry up and slow down\*(R" algorithm that prevents open-ended
loops from ever reaching the right-hand side.
.PP
As a special case, if the progress bar is drawn as two pairs of
identical brackets:
.PP
.Vb 1
\&    for (@candidates) {       ### Evaluating: [][]
\&
\&    for (@candidates) {       ### Evaluating: {}{}
\&
\&    for (@candidates) {       ### Evaluating: ()()
\&
\&    for (@candidates) {       ### Evaluating: <><>
.Ve
.PP
Then the bar grows by repeating bracket pairs:
.PP
.Vb 1
\&    Evaluating: [
\&
\&    Evaluating: []
\&
\&    Evaluating: [][
\&
\&    Evaluating: [][]
\&
\&    Evaluating: [][][
.Ve
.PP
etc.
.PP
Finally, progress bars don't have to have an animated component. They
can just report the loop's progress numerically:
.PP
.Vb 1
\&    for (@candidates) {       ### Evaluating (% done)
.Ve
.PP
which would animate (all of the same line):
.PP
.Vb 1
\&    Evaluating (0% done)
\&
\&    Evaluating (25% done)
\&
\&    Evaluating (50% done)
\&
\&    Evaluating (75% done)
\&
\&    Evaluating (100% done)
.Ve
.Sh "Time-Remaining Estimates"
.IX Subsection "Time-Remaining Estimates"
When a progress bar is used with a \f(CW\*(C`for\*(C'\fR loop, the module tracks how long
each iteration is taking and makes an estimate of how much time will be
required to complete the entire loop.
.PP
Normally this estimate is not shown, unless the estimate becomes large
enough to warrant informing the user. Specifically, the estimate will
be shown if, after five seconds, the time remaining exceeds ten seconds.
In other words, a time-remaining estimate is shown if the module
detects a \f(CW\*(C`for\*(C'\fR loop that is likely to take more than 15 seconds in
total. For example:
.PP
.Vb 4
\&    for (@seven_samurai) {      ### Fighting: [|||    ]
\&        fight();
\&        sleep 5;
\&    }
.Ve
.PP
would be animated like so:
.PP
.Vb 1
\&    Fighting: [                           ]
\&
\&    Fighting: [||||                       ]
\&
\&    Fighting: [|||||||||                  ]  (about 20 seconds remaining)
\&
\&    Fighting: [||||||||||||||             ]  (about 20 seconds remaining)
\&
\&    Fighting: [||||||||||||||||||         ]  (about 10 seconds remaining)
\&
\&    Fighting: [|||||||||||||||||||||||    ]  (less than 10 seconds remaining)
\&
\&    Fighting: [|||||||||||||||||||||||||||]
.Ve
.PP
The precision of the reported time-remaining estimate is deliberately vague,
mainly to prevent it being annoyingly wrong.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
In a sense, everything this module does is a diagnostic. All comments that
print anything, print it to \f(CW\*(C`STDERR\*(C'\fR.
.PP
However, the module itself has only one diagnostic:
.ie n .IP """Incomprehensible arguments: %s in call to \*(Aquse Smart::Comments""" 4
.el .IP "\f(CWIncomprehensible arguments: %s in call to \*(Aquse Smart::Comments\fR" 4
.IX Item "Incomprehensible arguments: %s in call to use Smart::Comments"
You loaded the module and passed it an argument that wasn't three\-or\-
more \f(CW\*(C`#\*(C'\fR's. Arguments like \f(CW\*(Aq###\*(Aq\fR, \f(CW\*(Aq####\*(Aq\fR, \f(CW\*(Aq#####\*(Aq\fR, etc. are
the only ones that the module accepts.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Smart::Comments can make use of an environment variable from your shell:
\&\f(CW\*(C`Smart_Comments\*(C'\fR. This variable can be specified either with a
true/false value (i.e. 1 or 0) or with the same arguments as may be
passed on the \f(CW\*(C`use\*(C'\fR line when loading the module (see \*(L"\s-1INTERFACE\s0\*(R").
The following table summarizes the behaviour:
.PP
.Vb 2
\&         Value of
\&    $ENV{Smart_Comments}          Equivalent Perl
\&
\&            1                     use Smart::Comments;
\&            0                      no Smart::Comments;
\&        \*(Aq###:####\*(Aq                use Smart::Comments qw(### ####);
\&        \*(Aq### ####\*(Aq                use Smart::Comments qw(### ####);
.Ve
.PP
To enable the \f(CW\*(C`Smart_Comments\*(C'\fR environment variable, you need to load the
module with the \f(CW\*(C`\-ENV\*(C'\fR flag:
.PP
.Vb 1
\&    use Smart::Comments \-ENV;
.Ve
.PP
Note that you can still specify other arguments in the \f(CW\*(C`use\*(C'\fR statement:
.PP
.Vb 1
\&    use Smart::Comments \-ENV, qw(### #####);
.Ve
.PP
In this case, the contents of the environment variable replace the \f(CW\*(C`\-ENV\*(C'\fR in
the argument list.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
The module requires the following modules:
.IP "\(bu" 4
Filter::Simple
.IP "\(bu" 4
version.pm
.IP "\(bu" 4
List::Util
.IP "\(bu" 4
Data::Dumper
.IP "\(bu" 4
Text::Balanced
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported. This module is probably even relatively safe with other
Filter::Simple modules since it is very specific and limited in what
it filters.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.PP
This module has the usual limitations of source filters (i.e. it looks
smarter than it is).
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-smart\-comments@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway  \f(CW\*(C`<DCONWAY@cpan.org>\*(C'\fR
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2005, Damian Conway \f(CW\*(C`<DCONWAY@cpan.org>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE\s0 \s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1LICENSED\s0 \s-1FREE\s0 \s-1OF\s0 \s-1CHARGE\s0, \s-1THERE\s0 \s-1IS\s0 \s-1NO\s0 \s-1WARRANTY\s0
\&\s-1FOR\s0 \s-1THE\s0 \s-1SOFTWARE\s0, \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0. \s-1EXCEPT\s0 \s-1WHEN\s0
\&\s-1OTHERWISE\s0 \s-1STATED\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND/OR\s0 \s-1OTHER\s0 \s-1PARTIES\s0
\&\s-1PROVIDE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EITHER\s0
\&\s-1EXPRESSED\s0 \s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0
\&\s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. \s-1THE\s0
\&\s-1ENTIRE\s0 \s-1RISK\s0 \s-1AS\s0 \s-1TO\s0 \s-1THE\s0 \s-1QUALITY\s0 \s-1AND\s0 \s-1PERFORMANCE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1WITH\s0
\&\s-1YOU\s0. \s-1SHOULD\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1PROVE\s0 \s-1DEFECTIVE\s0, \s-1YOU\s0 \s-1ASSUME\s0 \s-1THE\s0 \s-1COST\s0 \s-1OF\s0 \s-1ALL\s0
\&\s-1NECESSARY\s0 \s-1SERVICING\s0, \s-1REPAIR\s0, \s-1OR\s0 \s-1CORRECTION\s0.
.PP
\&\s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0 \s-1OR\s0 \s-1AGREED\s0 \s-1TO\s0 \s-1IN\s0 \s-1WRITING\s0
\&\s-1WILL\s0 \s-1ANY\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0, \s-1OR\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1WHO\s0 \s-1MAY\s0 \s-1MODIFY\s0 \s-1AND/OR\s0
\&\s-1REDISTRIBUTE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1AS\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1THE\s0 \s-1ABOVE\s0 \s-1LICENCE\s0, \s-1BE\s0
\&\s-1LIABLE\s0 \s-1TO\s0 \s-1YOU\s0 \s-1FOR\s0 \s-1DAMAGES\s0, \s-1INCLUDING\s0 \s-1ANY\s0 \s-1GENERAL\s0, \s-1SPECIAL\s0, \s-1INCIDENTAL\s0,
\&\s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1INABILITY\s0 \s-1TO\s0 \s-1USE\s0
\&\s-1THE\s0 \s-1SOFTWARE\s0 (\s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1LOSS\s0 \s-1OF\s0 \s-1DATA\s0 \s-1OR\s0 \s-1DATA\s0 \s-1BEING\s0
\&\s-1RENDERED\s0 \s-1INACCURATE\s0 \s-1OR\s0 \s-1LOSSES\s0 \s-1SUSTAINED\s0 \s-1BY\s0 \s-1YOU\s0 \s-1OR\s0 \s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A
\&\s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1SOFTWARE\s0), \s-1EVEN\s0 \s-1IF\s0
\&\s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0
\&\s-1SUCH\s0 \s-1DAMAGES\s0.
