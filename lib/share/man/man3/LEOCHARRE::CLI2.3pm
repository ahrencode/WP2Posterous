.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LEOCHARRE::CLI2 3"
.TH LEOCHARRE::CLI2 3 "2009-10-12" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
LEOCHARRE::CLI2 \- Some quick help for writing cli scripts.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In script.pl:
.PP
.Vb 8
\&   use LEOCHARRE::CLI2 
\&      \*(Aqko:\*(Aq, # options
\&      \*(Aq:all\*(Aq, # subs to import
\&      \*(AqThis program shows example usage.\*(Aq, # description of what script does
\&      \*(Aq(manpage suggested)\*(Aq, # where to look for more info in man pages
\&      \*(Aq[parent package name], # parent package name
\&      \*(Aqargv_cwd\*(Aq, # explicit sub import name
\&      ;
\&   
\&   our $VERSION = 1;
\&   
\&   $opt_o or die("Missing \-o opt");
\&   
\&   my @files_selected = argv_files();
\&   
\&   my @base_dir_selected = argv_cwd();
\&   
\&   my @all_dirs_selected = argv_dirs();
\&   
\&   my ($countfiles, $countdirs) = ( argv_dirs_count(), argv_files_count() );
\&   
\&   debug("You chose $countfiles files and $countdirs dirs.");
.Ve
.PP
Then to get help:
   $ script.pl \-h
.PP
To get version:
   $ script.pl \-v
.PP
To see debug:
   $ script.pl \-d \-o \*(L"my value\*(R" ./files* ./dirs*
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Some quick help for writing cli scripts.
Forces by default that \-h triggers help, that \-d triggers debug, and \-v version..
Automates help, debug, version etc.
If you use \s-1LEOCHARRE::CLI2\s0, we alter the \s-1OPTIONS\s0 automatically.
Also we automatically generate \s-1HELP\s0.
.SH "Environment Variables"
.IX Header "Environment Variables"
New environment variables are set. They are..
.ie n .Sh "$ENV{\s-1SCRIPT_FILENAME\s0}"
.el .Sh "\f(CW$ENV\fP{\s-1SCRIPT_FILENAME\s0}"
.IX Subsection "$ENV{SCRIPT_FILENAME}"
Holds name of your script, no leading path.
Is accessible to main.
.SH "SCRIPT_DESCRIPTION"
.IX Header "SCRIPT_DESCRIPTION"
If you define this, and you don't define \fIusage()\fR, the usage help output generated will 
contain this string.
.PP
.Vb 1
\&   use LEOCHARRE::CLI2 \*(AqThis is a script description because it has spaces.\*(Aq;
.Ve
.PP
When \-h is called, if there is not \fIusage()\fR defined, this would spit out:
.PP
.Vb 2
\&   /bin/file [OPTION]..
\&   This is a script description because it has spaces.
\&   
\&      \-d    debug
\&      \-h    help
\&      \-v    version
.Ve
.SH "SCRIPT PARENT PACKAGE"
.IX Header "SCRIPT PARENT PACKAGE"
.Vb 1
\&   use LEOCHARRE::CLI2 \*(Aq[MyPkg]\*(Aq;
.Ve
.SH "SCRIPT MAN PAGE"
.IX Header "SCRIPT MAN PAGE"
.Vb 1
\&   use LEOCHARRE::CLI2 \*(Aq(manpagename)\*(Aq;
.Ve
.SH "Argument Variables"
.IX Header "Argument Variables"
For path arguments on disk specified via \f(CW@ARGV\fR.
.PP
You can optionally use these to see any files, dirs, etc that a user defined in the cli.
These must all be paths that resolve to disk.
They all return abs path.
.PP
Files and dirs, holds absolute paths on disk.
Count holds number, 0 if none.
.PP
To make these accessible, import.
.PP
.Vb 2
\&   use LEOCHARRE::CLI2 \*(Aq:argv\*(Aq; # for all
\&   use LEOCHARRE::CLI2  qw/argv_files argv_files_count argv_dirs argv_dirs_count argv_cwd/; # same
.Ve
.PP
Usage: script ./pathtodir ./path2dir2 ./path2file.txt
Then in our script:
.PP
.Vb 2
\&   my @dirs = argv_dirs(); # holds abs path to dirs
\&   my $dirs_count = argv_dirs_count();
\&   
\&   argv_files_count() 
\&      or die("you forgot to specidy files on disk.");
.Ve
.PP
Note that this alters \f(CW@ARGV\fR.
.PP
If you wish to import these.. Either use export tag ':all' or ':argv'.
.Sh "\fIargv_cwd()\fP"
.IX Subsection "argv_cwd()"
Sometimes you want a destination dir to do something to.
You want the option for the user to say;
   script ./path_to/
.PP
But if none is provided, you want to assume './'.
   my \f(CW$base_dir\fR = \fIargv_cwd()\fR;
.Sh "\fIargv_files()\fP"
.IX Subsection "argv_files()"
Returns array of files abs paths. Undef if none.
.Sh "\fIargv_files_count()\fP"
.IX Subsection "argv_files_count()"
Returns count of files, 0 if none.
.Sh "\fIargv_dirs()\fP"
.IX Subsection "argv_dirs()"
Returns array of dirs abs paths. Undef if none.
.Sh "\fIargv_dirs_count()\fP"
.IX Subsection "argv_dirs_count()"
Returns count of dirs abs paths, 0 if none.
.Sh "\fIargv_cwd()\fP"
.IX Subsection "argv_cwd()"
Returns dirs chosen by user, or './' abs path.
.Sh "\s-1MODULES\s0 \s-1LOADED\s0 \s-1AND\s0 \s-1AVAILABLE\s0"
.IX Subsection "MODULES LOADED AND AVAILABLE"
\&\s-1YAML\s0, Carp, Cwd
.Sh "\fIabs_path()\fP, \fIcwd()\fP"
.IX Subsection "abs_path(), cwd()"
Available and exported if you choose :all
.Sh "\fIslurp()\fP"
.IX Subsection "slurp()"
Arg is file on disk.
If not there, warns and returns undef.
If can't do it, warns and returns undef.
Returns content.
If no content, warns and returns whatever was inside.
.PP
.Vb 1
\&   my $txt = slurp(\*(Aq./this.txt\*(Aq) or die;
.Ve
.PP
In scalar context returns all text.
In array context returns all lines, as list.
.Sh "\fIburp()\fP"
.IX Subsection "burp()"
Arg is path on disk, and content. Dumps to path.
Warns and returns undef on failure.
.PP
.Vb 1
\&   burp(\*(Aq./this.out\*(Aq,\*(Aqcontent\*(Aq) or die;
.Ve
.Sh "\fIyn()\fP"
.IX Subsection "yn()"
Argument is what to ask the user, they select y or n.
Returns bool.
Prompts user.
.PP
.Vb 3
\&   if (yn(\*(Aqplease say y to continue..\*(Aq)){
\&      warn " # continuing.. \en";
\&   }
.Ve
.Sh "\fIsq()\fP"
.IX Subsection "sq()"
Argument is thing to quote for shell use.
Shortcut to \fIString::ShellQuote::shell_quote()\fR.
.PP
.Vb 3
\&   my $weird = \*(Aq/home/myself/path to funny*named, file\*(Aq;
\&   my $quoted = sq($weird);
\&   my $quoted = sq $weird;
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
This uses Getopt::Std, it works very similar to Getopt::Std::Strict.
By default unless it is already there, \-d \-h and \-v flags are set to trigger
.PP
.Vb 3
\&   \-h will trigger help, if no usage() sub is defined, one is generated.
\&   \-d will enable debug
\&   \-v will print version and exit
.Ve
.SH "HELP"
.IX Header "HELP"
If you want to write your own help, define a \fIusage()\fR sub.
If you don't defined one, and the user says \-h, a help is automatically generated.
It will contain all your flags, name of script, etc.
.PP
In this example, we generate our own help, and a manual.
Usage simply returns a string.
.PP
.Vb 1
\&   use LEOCHARRE::CLI2;
\&   
\&   sub usage {
\&      q{script [OPTION]...
\&      \-h    help
\&      \-d    debug
\&      \-v    version
\&      
\&      Try \*(Aqman script\*(Aq for more info.
\&      }
\&   }
\&   
\&   _\|_END_\|_
\&   
\&   =pod
\&   
\&   =head1 NAME
\&   
\&   script
\&   
\&   =head1 DESCRIPTION
\&   
\&   Hi.. I do x y z.
.Ve
.PP
All cli should have a minimal help that triggers when the user says \-h.
If you define a \s-1SCRIPT_DESCRIPTION\s0, it will be placed in the usage generated.
.SH "CAVEATS"
.IX Header "CAVEATS"
Alpha software.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Getopt::Std::Strict
String::ShellQuote
\&\s-1YAML\s0
:<Carp>
Cwd
.SH "AUTHOR"
.IX Header "AUTHOR"
Leo Charre leocharre at cpan dot org
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can redistribute it and/or modify it under the same terms as Perl itself, i.e., under the terms of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public License\*(R".
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful, but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
