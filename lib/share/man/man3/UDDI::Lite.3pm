.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "UDDI::Lite 3"
.TH UDDI::Lite 3 "2009-09-30" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
UDDI::Lite \- Library for UDDI clients in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use UDDI::Lite;
\&  print UDDI::Lite
\&    \-> proxy(\*(Aqhttp://uddi.microsoft.com/inquire\*(Aq)
\&    \-> find_business(name => \*(Aqold\*(Aq)
\&    \-> result
\&    \-> businessInfos\->businessInfo\->serviceInfos\->serviceInfo\->name;
.Ve
.PP
The same code with autodispatch:
.PP
.Vb 3
\&  use UDDI::Lite +autodispatch => 
\&    proxy => \*(Aqhttp://uddi.microsoft.com/inquire\*(Aq
\&  ;
\&
\&  print find_business(name => \*(Aqold\*(Aq)
\&    \-> businessInfos\->businessInfo\->serviceInfos\->serviceInfo\->name;
.Ve
.PP
Or with importing:
.PP
.Vb 4
\&  use UDDI::Lite 
\&    \*(AqUDDI::Lite\*(Aq => [\*(Aq:inquiry\*(Aq],
\&    proxy => \*(Aqhttp://uddi.microsoft.com/inquire\*(Aq
\&  ;
\&
\&  print find_business(name => \*(Aqold\*(Aq)
\&    \-> businessInfos\->businessInfo\->serviceInfos\->serviceInfo\->name;
.Ve
.PP
Publishing \s-1API:\s0
.PP
.Vb 4
\&  use UDDI::Lite 
\&    import => [\*(AqUDDI::Data\*(Aq], 
\&    import => [\*(AqUDDI::Lite\*(Aq],
\&    proxy => "https://some.server.com/endpoint_fot_publishing_API";
\&
\&  my $auth = get_authToken({userID => \*(AqUSERID\*(Aq, cred => \*(AqCRED\*(Aq})\->authInfo;
\&  my $busent = with businessEntity =>
\&    name("Contoso Manufacturing"), 
\&    description("We make components for business"),
\&    businessKey(\*(Aq\*(Aq),
\&    businessServices with businessService =>
\&      name("Buy components"), 
\&      description("Bindings for buying our components"),
\&      serviceKey(\*(Aq\*(Aq),
\&      bindingTemplates with bindingTemplate =>
\&        description("BASDA invoices over HTTP post"),
\&        accessPoint(\*(Aqhttp://www.contoso.com/buy.asp\*(Aq),
\&        bindingKey(\*(Aq\*(Aq),
\&        tModelInstanceDetails with tModelInstanceInfo =>
\&          description(\*(Aqsome tModel\*(Aq),
\&          tModelKey(\*(AqUUID:C1ACF26D\-9672\-4404\-9D70\-39B756E62AB4\*(Aq)
\&  ;
\&  print save_business($auth, $busent)\->businessEntity\->businessKey;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
UDDI::Lite for Perl is a collection of Perl modules which provides a 
simple and lightweight interface to the Universal Description, Discovery
and Integration (\s-1UDDI\s0) server.
.PP
To learn more about \s-1UDDI\s0, visit http://www.uddi.org/.
.PP
The main features of the library are:
.IP "\(bu" 3
Supports both inquiry and publishing \s-1API\s0
.IP "\(bu" 3
Builded on top of SOAP::Lite module, hence inherited syntax and features
.IP "\(bu" 3
Supports easy-to-use interface with convinient access to (sub)elements
and attributes
.IP "\(bu" 3
Supports \s-1HTTPS\s0 protocol
.IP "\(bu" 3
Supports \s-1SMTP\s0 protocol
.IP "\(bu" 3
Supports Basic/Digest server authentication
.SH "OVERVIEW OF CLASSES AND PACKAGES"
.IX Header "OVERVIEW OF CLASSES AND PACKAGES"
This table should give you a quick overview of the classes provided by the
library.
.PP
.Vb 6
\& UDDI::Lite.pm
\& \-\- UDDI::Lite         \-\- Main class provides all logic
\& \-\- UDDI::Data         \-\- Provides extensions for serialization architecture
\& \-\- UDDI::Serializer   \-\- Serializes data structures to UDDI/SOAP package
\& \-\- UDDI::Deserializer \-\- Deserializes result into objects
\& \-\- UDDI::SOM          \-\- Provides access to deserialized object tree
.Ve
.Sh "UDDI::Lite"
.IX Subsection "UDDI::Lite"
All methods that UDDI::Lite gives you access to can be used for both
setting and retrieving values. If you provide no parameters, you'll
get current value, and if you'll provide parameter(s), new value
will be assigned and method will return object (if not stated something
else). This is suitable for stacking these calls like:
.PP
.Vb 4
\&  $uddi = UDDI::Lite
\&    \-> on_debug(sub{print@_})
\&    \-> proxy(\*(Aqhttp://uddi.microsoft.com/inquire\*(Aq)
\&  ;
.Ve
.PP
Order is insignificant and you may call \fInew()\fR method first. If you
don't do it, UDDI::Lite will do it for you. However, \fInew()\fR method
gives you additional syntax:
.PP
.Vb 4
\&  $uddi = new UDDI::Lite
\&    on_debug => sub {print@_},
\&    proxy => \*(Aqhttp://uddi.microsoft.com/inquire\*(Aq
\&  ;
.Ve
.PP
\&\fInew()\fR accepts hash with method names and values, and will call 
appropriate method with passed value.
.PP
Since \fInew()\fR is optional it won't be mentioned anymore.
.PP
Other available methods inherited from SOAP::Lite and most usable are:
.IP "\fIproxy()\fR" 4
.IX Item "proxy()"
Shortcut for \f(CW\*(C`transport\->proxy()\*(C'\fR. This lets you specify an endpoint and 
also loads the required module at the same time. It is required for dispatching \s-1SOAP\s0 
calls. The name of the module will be defined depending on the protocol 
specific for the endpoint. SOAP::Lite will do the rest work.
.IP "\fIon_fault()\fR" 4
.IX Item "on_fault()"
Lets you specify handler for on_fault event. Default behavior is die 
on transport error and does nothing on others. You can change this 
behavior globally or locally, for particular object.
.IP "\fIon_debug()\fR" 4
.IX Item "on_debug()"
Lets you specify handler for on_debug event. Default behavior is do 
nothing. Use +trace/+debug option for UDDI::Lite instead.
.PP
To change to \s-1UDDI\s0 Version 2, use the following pragma:
.PP
.Vb 1
\&  use UDDI::Lite uddiversion => 2;
.Ve
.Sh "UDDI::Data"
.IX Subsection "UDDI::Data"
You can use this class if you want to specify value and name for \s-1UDDI\s0 
elements. 
For example, \f(CW\*(C`UDDI::Data\->name(\*(AqbusinessInfo\*(Aq)\->value(123)\*(C'\fR will 
be serialized to \f(CW\*(C`<businessInfo>123</businessInfo>\*(C'\fR, as 
well as \f(CW\*(C`UDDI::Data\-\*(C'\fRname(businessInfo => 123)>.
.PP
If you want to provide names for your parameters you can either specify
.PP
.Vb 1
\&  find_business(name => \*(Aqold\*(Aq)
.Ve
.PP
or do it with UDDI::Data:
.PP
.Vb 1
\&  find_business(UDDI::Data\->name(name => \*(Aqold\*(Aq))
.Ve
.PP
Later has some advantages: it'll work on any level, so you can do:
.PP
.Vb 1
\&  find_business(UDDI::Data\->name(name => UDDI::Data\->name(subname => \*(Aqold\*(Aq)))
.Ve
.PP
and also you can create arrays with this syntax:
.PP
.Vb 3
\&  find_business(UDDI::Data\->name(name => 
\&    [UDDI::Data\->name(subname1 => \*(Aqname1\*(Aq), 
\&     UDDI::Data\->name(subname2 => \*(Aqname2\*(Aq)]))
.Ve
.PP
will be serialized into:
.PP
.Vb 6
\&  <find_business xmlns="urn:uddi\-org:api" generic="1.0">
\&    <name>
\&      <subname1>name1</subname1>
\&      <subname2>name2</subname2>
\&    </name>
\&  </find_business>
.Ve
.PP
For standard elements more convinient syntax is available:
.PP
.Vb 5
\&  find_business(
\&    findQualifiers(findQualifier(\*(AqsortByNameAsc\*(Aq,
\&                                 \*(AqcaseSensitiveMatch\*(Aq)),
\&    name(\*(AqM\*(Aq)
\&  )
.Ve
.PP
and
.PP
.Vb 5
\&  find_business(
\&    findQualifiers([findQualifier(\*(AqsortByNameAsc\*(Aq), 
\&                    findQualifier(\*(AqcaseSensitiveMatch\*(Aq)]), 
\&    name(\*(AqM\*(Aq)
\&  )
.Ve
.PP
both will generate:
.PP
.Vb 12
\&  <SOAP\-ENV:Envelope 
\&    xmlns:SOAP\-ENV="http://schemas.xmlsoap.org/soap/envelope/">
\&    <SOAP\-ENV:Body>
\&      <find_business xmlns="urn:uddi\-org:api" generic="1.0">
\&        <findQualifiers>
\&          <findQualifier>sortByNameAsc</findQualifier>
\&          <findQualifier>caseSensitiveMatch</findQualifier>
\&        </findQualifiers>
\&        <name>M</name>
\&      </find_business>
\&    </SOAP\-ENV:Body>
\&  </SOAP\-ENV:Envelope>
.Ve
.PP
You can use \s-1ANY\s0 valid combinations (according to \*(L"\s-1UDDI\s0 Programmer's 
\&\s-1API\s0 Specification\*(R"). If you try to generate something unusual, like 
\&\f(CW\*(C`name(name(\*(Aqmyname\*(Aq))\*(C'\fR, you'll get:
.PP
.Vb 1
\&  Don\*(Aqt know what to do with \*(Aqname\*(Aq and \*(Aqname\*(Aq elements ....
.Ve
.PP
If you \s-1REALLY\s0 need to do it, use \f(CW\*(C`UDDI::Data\*(C'\fR syntax described above.
.PP
As special case you can pass hash as the first parameter of method
call and values of this hash will be added as attributes to top element:
.PP
.Vb 1
\&  find_business({maxRows => 10}, UDDI::Data\->name(name => old))
.Ve
.PP
gives you
.PP
.Vb 3
\&  <find_business xmlns="urn:uddi\-org:api" generic="1.0" maxRows="10">
\&    ....
\&  </find_business>
.Ve
.PP
You can also pass back parameters exactly as you get it from method call
(like you probably want to do with authInfo).
.PP
You can get access to attributes and elements through the same interface:
.PP
.Vb 8
\&  my $list = find_business(name => old);
\&  my $bis = $list\->businessInfos;
\&  for ($bis\->businessInfo) {
\&    my $s = $_\->serviceInfos\->serviceInfo;
\&    print $s\->name,        # element
\&          $s\->businessKey, # attribute
\&          "\en";
\&  }
.Ve
.PP
To match advantages provided by \f(CW\*(C`with\*(C'\fR operator available in other 
languages (like \s-1VB\s0) we provide similar functionality that adds you 
flexibility:
.PP
.Vb 3
\&    with findQualifiers => 
\&      findQualifier => \*(AqsortByNameAsc\*(Aq,
\&      findQualifier => \*(AqcaseSensitiveMatch\*(Aq
.Ve
.PP
is the same as:
.PP
.Vb 4
\&    with(findQualifiers => 
\&      findQualifier(\*(AqsortByNameAsc\*(Aq),
\&      findQualifier(\*(AqcaseSensitiveMatch\*(Aq),
\&    )
.Ve
.PP
and:
.PP
.Vb 4
\&    findQualifiers\->with( 
\&      findQualifier(\*(AqsortByNameAsc\*(Aq),
\&      findQualifier(\*(AqcaseSensitiveMatch\*(Aq),
\&    )
.Ve
.PP
will all generate the same code as mentioned above:
.PP
.Vb 2
\&    findQualifiers(findQualifier(\*(AqsortByNameAsc\*(Aq,
\&                                 \*(AqcaseSensitiveMatch\*(Aq)),
.Ve
.PP
Advantage of \f(CW\*(C`with\*(C'\fR syntax is the you can specify both attributes and 
elements through the same interface. First argument is element where all 
other elements and attributes will be attached. Provided examples and 
tests cover different syntaxes.
.Sh "\s-1AUTODISPATCHING\s0"
.IX Subsection "AUTODISPATCHING"
UDDI::Lite provides autodispatching feature that lets you create 
code that looks similar for local and remote access.
.PP
For example:
.PP
.Vb 2
\&  use UDDI::Lite +autodispatch => 
\&    proxy => \*(Aqhttp://uddi.microsoft.com/inquire\*(Aq;
.Ve
.PP
tells autodispatch all \s-1UDDI\s0 calls to 
\&'http://uddi.microsoft.com/inquire'. All subsequent calls can look 
like:
.PP
.Vb 3
\&  find_business(name => \*(Aqold\*(Aq);
\&  find_business(UDDI::Data\->name(name => \*(Aqold\*(Aq));
\&  find_business(name(\*(Aqold\*(Aq));
.Ve
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
.IP "\(bu" 4
Interface is still subject to change.
.IP "\(bu" 4
Though \s-1HTTPS/SSL\s0 is supported you should specify it yourself (with 
\&\f(CW\*(C`proxy\*(C'\fR or \f(CW\*(C`endpoint\*(C'\fR) for publishing \s-1API\s0 calls.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
For now UDDI::Lite is distributed as part of SOAP::Lite package.
You can download it from ( http://soaplite.com/ ) 
or from \s-1CPAN\s0 ( http://search.cpan.org/search?dist=SOAP\-Lite ).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SOAP::Lite ( http://search.cpan.org/search?dist=SOAP\-Lite )
\&\s-1UDDI\s0 ( http://search.cpan.org/search?dist=UDDI )
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2004 Paul Kulchenko. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Kulchenko (paulclinger@yahoo.com)
